# PEP 440 -- 版本标识和依赖指定
+ translator: github.com/shendeguize
+ original link: [https://www.python.org/dev/peps/pep-0440/](https://www.python.org/dev/peps/pep-0440/)
+ update date: 2020.12.22

## 摘要
本篇PEP描述了一个用于明确Python软件发布版本以及明确了对于特定版本依赖的规范.

本文档描述了此前标准(PEP345和PEP386)中对于版本规范的要求中的一些局限性.

## 定义
本文中所提及的关键字含义可参考[RFC 2119](https://tools.ietf.org/html/rfc2119.html):  
关键字包括: "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", 和"OPTIONAL".

"项目(Project)"指可用于继承的软件组件.Projects包括Python库,框架,脚本,插件,应用,数据容器,或其他资源等,以及上述内容的各种组合.公共Python项目常注册于[Pypi](https://pypi.org/).

"发布(Release)"专指一个项目的某一特定快照.

"发布(Distributions)"指被打包好用于发布release的文件.

"构建工具(Build tools)"是用于开发系统,生产资源和二进制分发包库中运行的自动化工具.构建工具也可被集成工具唤起以构建以sdist发布而非预建的二进制归档发布的软件.

"索引服务器(Index servers)"是活动的且带有发布版本和依赖数据的并对允许的元数据有限定的发布注册.

"发布工具(Publication tools)"是用于在开发系统上运行,将资源和二进制发布包上传至索引服务器的自动化工具.

"安装工具(Installation tools)"是专用于在部署目标上运行,使用从索引服务器或其他指定位置上获得的资源和二进制分发包部署到目标系统上的集成工具.

"自动化工具(Automated tools)"是一个描述范围包括了构建工具,索引服务器,发布工具,集成工具和其他任何生产和使用发布版本及其依赖元数据的软件的综合术语.

## 版本规约
每一发布版本都可由一个公共的版本号来识别,这一识别器支持所有定义好的版本比较操作.

这篇版本规约用于描述一个特定发布提供的发布版本,也用于约束构建或运行软件时的所需依赖的版本.

### 公共版本号
典型的公共版本号必须(MUST)符合下述规约格式:

```
[N!]N(.N)*[{a|b|rc}N][.postN][.devN]
```

公共版本号不允许(MUST NOT)包含起始或结尾空格.

公共版本号必须(MUST)对与某一给定发布版本是独一无二的.

安装工具应该(SHOULD)忽略任何不符合本篇规约的版本号.但必须(MUST)包含下述的特定标准.安装工具可以(MAY)在检测到不兼容或者有歧义的版本时警告用户.

参见*附录B: 使用正则表达式解析版本字符串(Parsing version strings with regular expressions)*,这篇附录提供了一个用于检查对于典型范式的严格复合型检查的正则表达式.也提供了一个更宽容的正则表达式,这一表达式后续可能会需要额外规范作输入.

公共版本号被分为下述五部分:
+ 世代号(Epoch): N!
+ 发布号(Release): N(.N)*
+ 预发布号(Pre-release): {a|b|rc}N
+ 后发布号(Post-release): .postN
+ 开发版本号(Development): .devN

任何给定的发布都是"最终发布(final release)","预发布(pre-release)","后发布(post-release)"或者"开发版本发布(developmental release)"之一,具体参见后续章节.

所有的数字部分必须(MUST)为由ASCII数字组成的非负整数.

所有的数字部分必须(MUST)以其数值作为解释值或者比较而非作为文本.

所有的数字部分可以(MAY)是另,除了下述中对于发布号(Release)的情况中,数字部分是0除了作为版本排序中最小值以外无其他意义.

```
Note:
本篇约束格式允许一些很难读懂的版本号一更好的适应现有的公有或私有Python项目中的实际情况.
相应的,一些版本号的使用虽然被PEP允许,但是在新项目中强烈不建议这样使用.后续章节会著名相关细节.
```

### 本地版本号
本地版本号必须(MUST)符合下述格式:

```
<public version identifier>[+<local version label>]
```

本地版本号由一个普通的公共版本号(如前述)和任意的"本地版本标签(local version label)"组成.这两部分用加号在公共版本号后分割.本地版本标签没有特别的语义规范,但是有一些语法限制.

本地版本号用于指示完整API(以及如果可用的话,ABI)与上游项目相兼容的补充版本.例如,这些版本可额嗯由应用开发者或者系统集成者通过特定的后段bug修复在升级到新的上游发布会干扰到应用或其他集成系统(例如Linux发布等)时创建.

本地版本标签使得我们能够区分上游发布和下游集成者可能进行修改重新构建的发布.使用本地版本号并不影响某一发布,而是在应用于发布资源上时,提示可能存在与相应上游版本号不一致的代码.

为了保证本地版本号可以作为文件名和URL的一部分读取,以及为了避免与十六进制哈希表示不兼容,本地版本标签必须(MUST)使用下述允许使用的字符:

+ ASCII字母([a-z A-Z])
+ ASCII数字([0-9])
+ 句号(.)

本地版本号必须(MUST)一ASCII字母或者数字开始和结尾.

对本地版本号的比较和排序会分别考虑本地版本号中由.分割的每个部分.如果某个部分全部由ASCII数字组成,那么这一段应被视为整数,而如果某个部分包含ASCII字母,那么这一部分就按照字典序进行比较.在比较数字段和字典段时,数字段总是比字典段要大.在比较有较多段和较少段而且较短本地版本号能够完全匹配较长版本号的开头部分时,段数更多的本地版本号总是比包含更少段的本地版本号要大.

"上游项目"是指定义了其自有的公共版本号的项目."下游项目"是基于上游项目的,可能从后续上游项目中向后移植了安全修复和bug修复的项目.

本地版本号不应该(SHOULD NOT)用于将上游项目发布到索引服务器上,但是可以(MAY)用于区别从项目源单独构建的版本.本地版本号应该(SHOULD)在发布与公共版本号对应的上游项目版本API兼容的但是包含有额外更改(例如bug修复)的版本时在下游项目中使用.因为PyPI是只用于索引管理上游项目的,因此本地版本号不允许(MUST NOT)使用.

### 最终发布
包含发布号(release)和可选的世代号(epoch)组成的版本号定义为最终发布(final release).

发布号包含如果非负整数,由点号分割:

```
N(.N)*
```

一个项目的最终发布必须(MUST)连续递增.否则自动化工具无法正确升级这些项目.

对于发布号的法比较和排序是基于每个部分的依次数字值的.在比较句号分割段数不等的情况时,较短的版本号必要情况下由0补齐.

当需要对发布号需要在第一节后添加额外部分时,常用的方法时使用两端式(主版本.子版本(major.minor))或者三段式(主版本.子版本.微版本(major.minor.micro)).例如:

```
0.9
0.9.1
0.9.2
...
0.9.10
0.9.11
1.0
1.0.1
1.1
2.0
2.0.1
...
```

一个发布序列是由任意数量的有共同前缀的发布号组成的集合,例如3.3.1,3.3.5以及3.3.9.45是3.3发布序列的所有部分.

```
Note:

X.Y和X.Y.0不会被认为不同的发布号,因为上述分段规则描述中,在比较时会将X.Y补齐成X.Y.0.
```

同样也允许使用日期发布号.下述是使用年月来作为版本号的例子:

```
2012.4
2012.7
2012.10
2013.1
2013.6
...
```

### 预发布号
一些项目使用"alpha,beta,rc(release candidate发布候选)"的预发布周期来支持最终发布前用户的测试使用.

如果作为一个项目开发周期中的一部分,预发布由版本号中的予发布段来标识:

```
X.YaN   # Alpha release
X.YbN   # Beta release
X.YrcN  # Release Candidate
X.Y     # Final release
```

这样由发布号和预发布号组成的版本号定义为预发布(pre-release).

预发布由一个字母表顺序号来标明预发布阶段和一个非负整数值组成.对于某一发布的预发布由其发布阶段(alpha,beta,rc)排序,随后由其发布阶段中的数值进行排序.

安装工具可以(MAY)支持`c`或者`rc`两种发布方式以适配现存传统发布包.

安装工具应该(SHOULD)认为`c`和`rc`两种描述是等价的(即`c1`和`rc1`两个版本等同).

构建工具和发布工具以及索引服务器应该(SHOULD)禁止对于某一发布段同时存在`c`和`rc`两种段.

### 后发布号
一些项目会使用后发布号来定位最终发布中不干扰部署软件的小错误(例如发布记录中的一些错误修正等).


如作为项目开发周期中的一部分,这些后发布是由版本号中的后发布号字段指出的:


```
X.Y.postN    # Post-release
```

包含后发布号字段但是不包含开发发布字段的版本号被叫做后发布版本.


后发布字段由`.post`字符串以及在此后的非负整数组成.后发布号依据数字部分进行排序,位次紧随在享用发布版本后,先于后续发布版本.


```
Note:
强烈不建议使用后发布号来发布包含带有bug修复的维护版本.通常来说,更好的方式是使用一个更长的发布号并使用发布号的最后一段来描述维护版本.
```

后发布号也允许用于预发布:

```
X.YaN.postM   # Post-release of an alpha release
X.YbN.postM   # Post-release of a beta release
X.YrcN.postM  # Post-release of a release candidate
```

```
Note:
强烈不建议对于一个预发布版本使用后发布号,因为会让人类使用者难以理解版本号.通常来说,直接通过增加预发布版本号的数字部分即可.
```

### 开发发布号
一些项目会定期发布开发版本,以及一些系统打包者(尤其是对于Linux发布而言)会希望直接从元版本控制中创建不会与后续项目发布冲突的早期发布.

如果作为项目开发周期的一部分,这些开发发布版本是由包含在版本号中的开发发布字段确定的:

```
X.Y.devN    # Developmental release
```

包含开发发布字段的版本号叫做开发发布(developmental release).

开发发布字段包括字符串`.dev`以及紧随其后的非负整数组成.开发发布由其数字部分排序,在其对应的发布版本前(且早于对应版本的预发布版本),低于任何先前版本发布(包括早先版本的后发布).

开发发布也允许用于预发布和后发布中:

```
X.YaN.devM       # Developmental release of an alpha release
X.YbN.devM       # Developmental release of a beta release
X.YrcN.devM      # Developmental release of a release candidate
X.Y.postN.devM   # Developmental release of a post-release
```

```
Note:
尽管对于持续集成(CI)可能很有用,但也强烈不推荐发布预发布的开发发布到公共索引服务器上.因为这会使得人类使用者难以理解版本号.如果这样的发布有必要发布,更简明的方式就是发布一个新的预发布版本.
强烈不建议发布后发布版本的开发发布,但是对于那些用后发布来管理包含了代码更改的全部维护发布的项目也可能可以.
```

### 版本世代
如果包含世代号,世代号要在所有部分前,由叹号分割:

```
E!X.Y  # Version identifier with epoch
```

如果没有额外表明世代号,默认为0.

大多数版本号都不包含世代号,因为世代号只适用于项目改变了版本号模式且会导致正常版本号排序方式会出错的情况下.例如如果一个项目使用日期模式例如`2014.04`然后想要切换到语义版本号例如`1.0`,那么按照原有的版本号规则,新发布版本就会被认为比日期版本旧:

```
1.0
1.1
2.0
2013.10
2014.04
```

在使用显式的世代号进行标明后,后一世代版本就可以在早一世代版本后正确排序:

```
2013.10
2014.04
1!1.0
1!1.1
1!2.0
```

### 规范化
为了和现有版本号更好的兼容,在解析版本号时有一些可选的语法是必须(MUST)考虑到的.这些语法应被规范化如上文所规范格式并必须(MUST)考虑到的.

#### 大小写敏感性
所有的ASCII字符在版本号中都是大小写不敏感的,需要被规范成为小写字符.例如`1.1RC1`要被规范成`1.1rc1`.

#### 整数规范化
所有的整数都要由内置类型`int()`表述并转化成字符串输出.这意味着整数版本`00`会转化成`0`而`09000`会被转化成`9000`.但对于包含字母数字混合段的本地版本号不生效,例如`1.0+foo0100`已经是其正规化的版本.

#### 预发布版本分割符
预发布允许`.`,`-`或者`_`作为发布段和预发布段之间的分割符.通常情况下是不需要分割符的.这允许了诸如`1.1.a1`或者`1.1-a1`之类的情况的出现,而这些情况会被正规化成`1.1a1`.这一规范化也允许预发布字段中的字符和数字部分的分割符的使用,例如`1.0a.1`会被规范化为`1.0a1`.






